msgid ""
msgstr ""
"Project-Id-Version: torchvision 0.8.0.9000\n"
"POT-Creation-Date: 2025-12-30 11:15+0100\n"
"PO-Revision-Date: 2025-12-30 11:19+0100\n"
"Last-Translator: Christophe Regouby <christophe.regouby@free.fr>\n"
"Language-Team: \n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.8\n"
"X-Poedit-SourceCharset: UTF-8\n"

#: collection-catalog.R:90 collection-catalog.R:170
msgid "Invalid collection. Must be one of:"
msgstr "Collection non valide. Doit être l'une des suivantes :"

#: collection-catalog.R:90 collection-catalog.R:170
msgid ","
msgstr ""

#: collection-catalog.R:104
msgid "No datasets found matching criteria"
msgstr "Aucun ensemble de données ne correspond aux critères."

#: collection-rf100-doc.R:157
msgid ""
"Dataset {.val {self$dataset}} split {.val {self$split}} of {.cls {class(self)"
"[[1]]}} (~{.emph {self$archive_size}}) will be downloaded and processed if "
"not already available."
msgstr ""
"La partition {.val {self$split}} du jeu de données {.cls {class(self)[[1]]}} "
"(de taille ~{.emph {self$archive_size}}) sera téléchargée et traitée si elle "
"n'est pas déjà disponible."

#: collection-rf100-doc.R:162
msgid ""
"Dataset not found. Use download=TRUE or check that parquet files exist at "
"the expected paths."
msgstr ""
"Jeu de données introuvable. Veuillez ajouter `download = TRUE` pour le "
"télécharger, ou vérifier que le fichier `.parquet` existe à l'emplacement "
"attendu."

#: collection-rf100-doc.R:174
msgid ""
"{.cls {class(self)[[1]]}} dataset loaded with {self$.length()} images for "
"split {.val {self$split}}."
msgstr ""
"Le jeu de données {.cls {class(self)[[1]]}} est disponible avec "
"{self$.length()} images pour la partition {.val {self$split}}."

#: collection-rf100-doc.R:179
msgid "Downloading {.val {self$dataset}}..."
msgstr "Téléchargement de {.val {self$dataset}}..."

#: collection-rf100-doc.R:184
msgid "Corrupt file! Delete the cached files and try again."
msgstr "Fichier corrompu. Supprimez le fichier en cache et recommencez."

#: conditions.R:2
msgid "type_error"
msgstr ""

#: conditions.R:6
msgid "value_error"
msgstr ""

#: conditions.R:10
msgid "runtime_error"
msgstr ""

#: conditions.R:14
msgid "not_implemented_error"
msgstr ""

#: conditions.R:18
msgid "warning"
msgstr ""

#: conditions.R:35
msgid "stop_iteration_error"
msgstr ""

#: conditions.R:41
msgid "deprecated"
msgstr ""

#: dataset-caltech.R:61 dataset-cifar.R:52 dataset-coco.R:97 dataset-coco.R:289
#: dataset-eurosat.R:57 dataset-fer.R:63 dataset-fgvc.R:91 dataset-flickr.R:69
#: dataset-flickr.R:231 dataset-flowers.R:92 dataset-lfw.R:108
#: dataset-lfw.R:242 dataset-mnist.R:86 dataset-mnist.R:239
#: dataset-oxfordiiitpet.R:71 dataset-oxfordiiitpet.R:279
#: dataset-oxfordiiitpet.R:343 dataset-pascal.R:136 dataset-pascal.R:296
#: dataset-places365.R:98
msgid ""
"Dataset {.cls {class(self)[[1]]}} (~{.emph {self$archive_size}}) will be "
"downloaded and processed if not already available."
msgstr ""
"Le jeu de données {.cls {class(self)[[1]]}} (de taille ~{.emph "
"{self$archive_size}}) sera téléchargé et traité s'il n'est pas déjà "
"disponible."

#: dataset-caltech.R:66 dataset-caltech.R:187 dataset-coco.R:102
#: dataset-coco.R:294 dataset-eurosat.R:64 dataset-fer.R:70
#: dataset-flowers.R:97 dataset-lfw.R:113 dataset-lfw.R:247 dataset-mnist.R:91
#: dataset-mnist.R:244 dataset-mnist.R:398 dataset-oxfordiiitpet.R:76
#: dataset-oxfordiiitpet.R:284 dataset-oxfordiiitpet.R:348 dataset-pascal.R:141
#: dataset-pascal.R:301 dataset-places365.R:103 dataset-plankton.R:89
#: dataset-rf100-peixos.R:70
msgid "Dataset not found. You can use `download = TRUE` to download it."
msgstr ""
"Jeu de données introuvable. Veuillez ajouter `download = TRUE` pour le "
"télécharger."

#: dataset-caltech.R:84 dataset-caltech.R:208 dataset-lfw.R:135
#: dataset-lfw.R:282 dataset-oxfordiiitpet.R:95 dataset-oxfordiiitpet.R:298
#: dataset-oxfordiiitpet.R:362 dataset-pascal.R:149 dataset-pascal.R:319
#: dataset-plankton.R:93
msgid ""
"{.cls {class(self)[[1]]}} dataset loaded with {self$.length()} images across "
"{length(self$classes)} classes."
msgstr ""
"Le jeu de données {.cls {class(self)[[1]]}} est disponible avec "
"{self$.length()} images réparties en {length(self$classes)} classes."

#: dataset-caltech.R:117 dataset-coco.R:192 dataset-eurosat.R:81
#: dataset-flickr.R:136 dataset-lfw.R:146 dataset-oxfordiiitpet.R:107
#: dataset-pascal.R:158 dataset-plankton.R:100 dataset-rf100-peixos.R:77
msgid "Downloading {.cls {class(self)[[1]]}}..."
msgstr "Téléchargement de {.cls {class(self)[[1]]}}..."

#: dataset-caltech.R:125 dataset-cifar.R:111 dataset-coco.R:198
#: dataset-eurosat.R:88 dataset-fer.R:129 dataset-flowers.R:136
#: dataset-lfw.R:155 dataset-lfw.R:168 dataset-mnist.R:121 dataset-mnist.R:269
#: dataset-mnist.R:417 dataset-oxfordiiitpet.R:115 dataset-pascal.R:168
#: dataset-places365.R:182 dataset-plankton.R:105 dataset-rf100-peixos.R:82
#: models-facenet.R:128 models-facenet.R:174 models-facenet.R:228
#: models-facenet.R:312 models-vit.R:49
msgid "Corrupt file! Delete the file in {archive} and try again."
msgstr "Fichier corrompu. Supprimez le fichier {archive} et recommencez."

#: dataset-caltech.R:136 dataset-cifar.R:115 dataset-coco.R:204
#: dataset-eurosat.R:104 dataset-fer.R:134 dataset-fgvc.R:178
#: dataset-flickr.R:154 dataset-flowers.R:158 dataset-lfw.R:175
#: dataset-mnist.R:141 dataset-mnist.R:305 dataset-oxfordiiitpet.R:154
#: dataset-pascal.R:191 dataset-rf100-peixos.R:94 tiny-imagenet-dataset.R:67
msgid ""
"Dataset {.cls {class(self)[[1]]}} downloaded and extracted successfully."
msgstr ""
"Le jeu de données {.cls {class(self)[[1]]}} a été téléchargé et extrait avec "
"succès."

#: dataset-caltech.R:182
msgid ""
"Dataset {.cls {class(self)[[1]]}} (~{.emph {self$archive_size}}) will be "
"downloaded and processed if not already cached."
msgstr ""
"Le jeu de données {.cls {class(self)[[1]]}} de taille (~{.emph "
"{self$archive_size}}) sera téléchargé et traité s'il n'est pas déjà "
"disponible."

#: dataset-cifar.R:59
msgid "Files not found. Use download = TRUE"
msgstr "Fichier introuvable. Veuillez utiliser `download = TRUE`"

#: dataset-cifar.R:79
msgid ""
"Dataset {.cls {class(self)[[1]]}} loaded with {length(self$y)} images across "
"{length(self$classes)} classes."
msgstr ""
"Le jeu de données {.cls {class(self)[[1]]}} contient {length(self$img_path)} "
"images réparties en {length(self$classes)} classes."

#: dataset-cifar.R:106 dataset-fer.R:124 dataset-fgvc.R:169
#: dataset-flowers.R:131 dataset-mnist.R:125 dataset-mnist.R:260
#: tiny-imagenet-dataset.R:43
msgid "Downloading {.cls {class(self)[[1]]}} ..."
msgstr "Téléchargement de {.cls {class(self)[[1]]}}..."

#: dataset-coco.R:107 dataset-coco.R:299
msgid ""
"{.cls {class(self)[[1]]}} dataset loaded with {length(self$image_ids)} "
"images."
msgstr ""
"Jeu de données {.cls {class(self)[[1]]}} chargé avec "
"{length(self$image_ids)} images."

#: dataset-coco.R:310
msgid "Index out of bounds"
msgstr "Index hors limites."

#: dataset-eurosat.R:69
msgid ""
"Dataset {.cls {class(self)[[1]]}} loaded with {length(self$data)} images "
"across {length(self$classes)} classes."
msgstr ""
"Le jeu de données {.cls {class(self)[[1]]}} contient {length(self$data)} "
"images réparties en {length(self$classes)} classes."

#: dataset-eurosat.R:92
msgid "Extracting {.cls {class(self)[[1]]}} archive..."
msgstr "Extraction de l'archive de {.cls {class(self)[[1]]}}..."

#: dataset-eurosat.R:94
msgid "Extraction of {.cls {class(self)[[1]]}} is complete."
msgstr "Extraction de l'archive {.cls {class(self)[[1]]}} terminée..."

#: dataset-eurosat.R:98
msgid "Downloading {.cls {class(self)[[1]]}} split file: {self$split_url}"
msgstr ""
"Téléchargement du fichier de partition de {.cls {class(self)[[1]]}} depuis "
"{self$split_url} ..."

#: dataset-eurosat.R:102
msgid "Downloaded split file `{self$split_file}` is empty."
msgstr "Le fichier téléchargé `{self$split_file}` est vide."

#: dataset-eurosat.R:117
msgid "Image file `{filename}` not found."
msgstr "Fichier d'image `{filename}` introuvable."

#: dataset-eurosat.R:129
msgid "Label `{label}` not found in class_to_idx."
msgstr "Le label `{label}` ne fait pas partie de `class_to_idx`."

#: dataset-fer.R:83 dataset-fer.R:91 dataset-mnist.R:272
#: tiny-imagenet-dataset.R:48
msgid "Processing {.cls {class(self)[[1]]}} ..."
msgstr "Préparation de {.cls {class(self)[[1]]}} ..."

#: dataset-fgvc.R:96 dataset-flickr.R:73 dataset-flickr.R:235
msgid "Dataset not found. Use `download = TRUE` to download it."
msgstr ""
"Jeu de données introuvable. Veuillez ajouter `download = TRUE` pour le "
"télécharger."

#: dataset-fgvc.R:128
msgid ""
"{.cls {class(self)[[1]]}} dataset loaded with {length(self$image_paths)} "
"images across {length(self$classes[[annotation_level]])} classes."
msgstr ""
"Le jeu de données {.cls {class(self)[[1]]}} a été chargé avec "
"{length(self$image_paths)} images réparties en "
"{length(self$classes[[annotation_level]])} classes."

#: dataset-fgvc.R:173 dataset-flickr.R:143
msgid "Corrupt file! Delete the file at {archive} and try again."
msgstr "Fichier corrompu. Supprimez le fichier {archive} et recommencez."

#: dataset-flickr.R:111
msgid "The following IDs are missing captions: {paste(missing, collapse=', ')}"
msgstr "Les ID suivants n'ont pas de légende : {paste(missing, collapse=', ')}"

#: dataset-flickr.R:128 dataset-flickr.R:256
msgid ""
"{.cls {class(self)[[1]]}} dataset loaded with {length(self$images)} images "
"across {length(self$classes)} classes."
msgstr ""
"Le jeu de données {.cls {class(self)[[1]]}} contient {length(self$data)} "
"images réparties en {length(self$classes)} classes."

#: dataset-flowers.R:102
msgid ""
"Split {.val {self$split}} of dataset {.cls {class(self)[[1]]}} loaded with "
"{self$.length()} samples."
msgstr ""
"La partition {.val {self$split}} du jeu de données {.cls {class(self)[[1]]}} "
"est chargée avec {length(self$img_path)} images."

#: dataset-flowers.R:126
msgid ""
"Split {.val {self$split}} of dataset {.cls {class(self)[[1]]}} is already "
"processed and cached."
msgstr ""
"La partition {.val {self$split}} du jeu de données {.cls {class(self)[[1]]}} "
"a déjà été préparé et mis en cache."

#: dataset-flowers.R:140
msgid "{.cls {class(self)[[1]]}} Extracting images and processing dataset..."
msgstr ""
"Extraction d'image et préparation du dataset {.cls {class(self)[[1]]}}..."

#: dataset-mnist.R:102
msgid ""
"Dataset {.cls {class(self)[[1]]}} loaded with {length(self$targets)} images."
msgstr ""
"Jeu de données {.cls {class(self)[[1]]}} chargé avec {length(self$targets)} "
"images."

#: dataset-mnist.R:126
msgid "Processing {.cls {class(self)[[1]]}}..."
msgstr "Préparation de {.cls {class(self)[[1]]}} ..."

#: dataset-mnist.R:393
msgid ""
"{.cls {class(self)[[1]]}} (~{.emph {self$archive_size}}) will be downloaded "
"and processed if not already available."
msgstr ""
"Le jeu de données {.cls {class(self)[[1]]}} (de taille ~{.emph "
"{self$archive_size}}) sera téléchargé et traité s'il n'est pas déjà "
"disponible."

#: dataset-mnist.R:404
msgid ""
"Split {.val {self$split}} of dataset {.val {self$dataset}} from {.cls "
"{class(self)[[1]]}} processed successfully!"
msgstr ""
"La partition {.val {self$split}} du jeu de données {.val {self$dataset}} de "
"{.cls {class(self)[[1]]}} a été traitée avec succès !"

#: dataset-places365.R:128
msgid ""
"{.cls {class(self)[[1]]}} Split '{self$split}' loaded with {length(self)} "
"samples."
msgstr ""
"{.cls {class(self)[[1]]}} La partition '{self$split}' est chargée et "
"contient {length(self)} échantillons."

#: dataset-places365.R:155
msgid "Invalid split: {self$split}"
msgstr "Partition non valide : {self$split}"

#: dataset-places365.R:163
msgid "Downloading {.cls {class(self)[[1]]}} split '{self$split}'..."
msgstr ""
"Téléchargement du fichier de partition '{self$split}' de {.cls {class(self)"
"[[1]]} ..."

#: dataset-plankton.R:84
msgid ""
"Split {.val {self$split}} of dataset {.cls {class(self)[[1]]}} (~{.emph "
"{self$archive_size}}) will be downloaded and processed if not already "
"available."
msgstr ""
"La partition {.val {self$split}} du jeu de données {.cls {class(self)[[1]]}} "
"(de taille ~{.emph {self$archive_size}}) sera téléchargée et traitée si elle "
"n'est pas déjà disponible."

#: extension.R:2
msgid ""
"has_ops() Not implemented yet. https://github.com/pytorch/vision/blob/"
"b266c2f1a5c10f5caf22f5aea7418acc392a5075/torchvision/extension.py#L60"
msgstr ""
"`has_ops()` n'est aps encore implémenté. https://github.com/pytorch/vision/"
"blob/b266c2f1a5c10f5caf22f5aea7418acc392a5075/torchvision/extension.py#L60"

#: extension.R:8
msgid ""
"Couldn't load custom C++ ops. This can happen if your torch and torchvision\n"
"       versions are incompatible, or if you had errors while compiling "
"torchvision\n"
"       from source. Please reinstall torchvision so that it matches your "
"torch install."
msgstr ""
"La librairie spécifique C++ ops ne peut être chargée. C'est peut être le "
"symptôme de \n"
"    version de torch et de torchvision incompatibles, ou si vous avez eu des "
"erreurs lors de\n"
"    la compilation de torchvision depuis les sources. Veuillez réinstaller "
"torchvision pour qu'il\n"
"    corresponde à la version de torch."

#: folder-dataset.R:23
msgid ""
"Both extensions and is_valid_file cannot be None or not None at the same time"
msgstr ""
"Vous pouvez configurer `extensions` ou `is_valid_files` mais pas les deux."

#: folder-dataset.R:151
msgid "unknown extension {ext} in path {path}"
msgstr "Extension {ext} inconnue dans le répertoire {path}."

#: models-alexnet.R:58 models-inception.R:434 models-mobilenetv2.R:17
#: models-mobilenetv3_large.R:18
msgid ""
"Model weights for {.cls {class(model)[1]}} ({.emph {r[3]}}) will be "
"downloaded and processed if not already available."
msgstr ""
"Les poids du modèle pour {.cls {class(model)[1]}} ({.emph {r[3]}}) seront "
"téléchargés et traités s'ils ne sont pas déjà disponibles."

#: models-alexnet.R:61 models-convnext_segmentation.R:451
#: models-convnext_segmentation.R:492 models-convnext_segmentation.R:533
#: models-deeplabv3.R:262 models-efficientnet.R:228 models-efficientnetv2.R:204
#: models-faster_rcnn.R:977 models-faster_rcnn.R:1011 models-faster_rcnn.R:1062
#: models-faster_rcnn.R:1097 models-fcn.R:185 models-fcn.R:233
#: models-inception.R:437 models-mobilenetv2.R:20 models-mobilenetv3.R:338
#: models-mobilenetv3_large.R:21 models-resnet.R:248 models-vgg.R:114
msgid "Corrupt file! Delete the file in {state_dict_path} and try again."
msgstr ""
"Fichier corrompu. Supprimez le fichier {state_dict_path} et recommencez."

#: models-convnext.R:80
msgid "Unsupported data format"
msgstr "Format de données non-supporté"

#: models-convnext.R:194
msgid "arch must be a single character string."
msgstr "arch doit être une chaîne de caractères unique."

#: models-convnext.R:202
msgid "depths and dims must be vectors of length 4."
msgstr "`depth` et `dim` doivent être des vecteurs de longueur 4."

#: models-convnext.R:213
msgid "Pretrained model for"
msgstr "Modèle pré-entraîné pour"

#: models-convnext.R:213
msgid "is not available."
msgstr "n'est pas disponible."

#: models-convnext_detection.R:211 utils.R:40
msgid "{.var num_classes} must be positive"
msgstr "{.var num_classes} doit être positif"

#: models-convnext_segmentation.R:429 models-convnext_segmentation.R:470
#: models-convnext_segmentation.R:511 models-deeplabv3.R:231
msgid "`pretrained_backbone` ignored when `pretrained = TRUE`."
msgstr "`pretrained_backbone` est ignoré lorsque `pretrained = TRUE`."

#: models-convnext_segmentation.R:448 models-convnext_segmentation.R:489
#: models-convnext_segmentation.R:530 models-deeplabv3.R:259
msgid "Downloading {.cls {arch}} pretrained weights (~{.emph {info[3]}}) ..."
msgstr ""
"Téléchargement des poids pré-entraînés {.cls {arch}} (~{.emph {info[3]}}) ..."

#: models-efficientnet.R:225 models-efficientnetv2.R:201 models-resnet.R:245
#: models-vgg.R:111
msgid ""
"Model weights for {.cls {arch}} ({.emph {r[3]}}) will be downloaded and "
"processed if not already available."
msgstr ""
"Les poids du modèle pour {.cls {arch}} ({.emph {r[3]}}) seront téléchargés "
"et traités s'ils ne sont pas déjà disponibles."

#: models-faster_rcnn.R:969 models-faster_rcnn.R:1003 models-faster_rcnn.R:1054
#: models-faster_rcnn.R:1089
msgid "Pretrained weights require num_classes = 91."
msgstr "Les poids pré-entraînés nécessitent `num_classes = 91`."

#: models-faster_rcnn.R:974 models-faster_rcnn.R:1008 models-faster_rcnn.R:1059
#: models-faster_rcnn.R:1094 models-fcn.R:182 models-fcn.R:230 models-vit.R:44
msgid ""
"Model weights for {.cls {name}} (~{.emph {r[3]}}) will be downloaded and "
"processed if not already available."
msgstr ""
"Les poids du modèle pour {.cls {name}} (~{.emph {r[3]}}) seront téléchargés "
"et traités s'ils ne sont pas déjà disponibles."

#: models-fcn.R:162 models-fcn.R:210
msgid "Pretrained weights require num_classes = 21."
msgstr "Les poids pré-entraînés nécessitent `num_classes = 21`."

#: models-inception.R:16
msgid ""
"The default weight initialization of inception_v3 will be changed in future "
"releases of"
msgstr ""
"L'initialisation des poids par défaut de inception_v3 sera changé dans les "
"prochaines version de"

#: models-inception.R:17
msgid ""
"torchvision. If you wish to keep the old behavior (which leads to long "
"initialization times"
msgstr ""
"torchvision. Pour garder les anciens poids (qui allongent temps "
"d'initialisation"

#: models-inception.R:18
msgid "due to scipy/scipy#11299), please set init_weights={.val TRUE}."
msgstr ""
"à cause de scipy/scipy#11299) il faut configurer `init_weights={.val TRUE}`."

#: models-inception.R:24
msgid ""
"length of {.arg inception_blocks} should be 7 instead of "
"{length(inception_blocks)}"
msgstr ""
"La longueur de {.arg inception_blocks} doit être 7 et non "
"{length(inception_blocks)}."

#: models-mobilenetv2.R:65
msgid ""
"{.var inverted_residual_setting} should be non-empty or a 4-element list, "
"got {.val {inverted_residual_setting}}"
msgstr ""
"{.var inverted_residual_setting} doit être non vide ou une liste de 4 "
"éléments, et non {.val {inverted_residual_setting}}."

#: models-mobilenetv3.R:148
msgid "illegal stride value"
msgstr "valeur illégale pour `stride`"

#: models-resnet.R:34
msgid "basic_block only supports groups=1 and base_width=64"
msgstr "`basic_block` ne fonctionne qu'avec `groups=1` et `base_width=64`."

#: models-resnet.R:37
msgid "Dilation > 1 not supported in basic_block"
msgstr "Pas de `dilation` > 1 dans le `basic_block`."

#: models-resnet.R:145
msgid "replace_stride_with_dilation should be NULL"
msgstr "`replace_stride_with_dilation` doit être `NULL`"

#: models-resnet.R:146
msgid "or a 3-element tuple, got {length(replace_stride_with_dilation)}"
msgstr ""
"ou une liste de 3 éléments, et non pas "
"{length(replace_stride_with_dilation)} éléments."

#: ops-boxes.R:195
msgid "Unsupported Bounding Box Conversions for given in_fmt and out_fmt"
msgstr ""
"Le type de conversion demandé pour la boite englobante n'existe pas pour "
"`in_fmt` et `out_fmt`."

#: ops-boxes.R:308
msgid "(boxes1[, 3:N] >= boxes1[, 1:2])$all() not TRUE"
msgstr ""

#: ops-boxes.R:310
msgid "(boxes2[, 3:N] >= boxes2[, 1:2])$all() not TRUE"
msgstr ""

#: transforms-defaults.R:298
msgid "must be positive if a single number"
msgstr "doit être positif quand c'est une valeur unique"

#: transforms-defaults.R:308
msgid "out of bounds."
msgstr "Index hors limites."

#: transforms-defaults.R:346 transforms-defaults.R:402
msgid "degrees must be positive if it's a single value"
msgstr "`degrees` doit être positif quand c'est une valeur unique."

#: transforms-defaults.R:351 transforms-defaults.R:407
msgid "degrees must be length 1 or 2"
msgstr "`degrees` doit être de longueur 1 ou 2"

#: transforms-defaults.R:414
msgid "translate must be length 2"
msgstr "`translate` doit être de longueur 2."

#: transforms-defaults.R:417
msgid "translate must be between 0 and 1"
msgstr "`translate` doit être pris entre 0 et 1."

#: transforms-defaults.R:424
msgid "scale must be length 2"
msgstr "`scale` doit être de longueur 2."

#: transforms-defaults.R:427
msgid "scale must be positive"
msgstr "`scale` doit être positive."

#: transforms-defaults.R:436
msgid "shear must be positive if it's a single value"
msgstr "`shear` doit être positif quand c'est une valeur unique."

#: transforms-defaults.R:441
msgid "shear's length must be 1, 2, or 4"
msgstr "La longueur de `shear` doit être 1, 2 ou 4."

#: transforms-defaults.R:579
msgid "not implemented for {class(x)}"
msgstr "n'est pas supporté pour {class(x)}."

#: transforms-tensor.R:18
msgid "The cast from {img$dtype} to {dtype} cannot be performed safely."
msgstr ""
"La conversion de {img$dtype} en {dtype} ne peut pas être faite sans risque."

#: transforms-tensor.R:72
msgid ""
"std evaluated to zero after conversion to {dtype}, leading to division by "
"zero."
msgstr ""
"Après conversion en {dtype}, l'écart-type est à zéro, ce qui conduit à une "
"division par zéro."

#: transforms-tensor.R:98
msgid "This interpolation mode is unsupported with Tensor input"
msgstr ""
"Ce mode d'interpolation n'est pas applicable à une entrée de type tenseur."

#: transforms-tensor.R:101
msgid "Size must be a numeric vector of length 1 or 2."
msgstr "`size` doit être un vecteur numérique de longueur 1 ou 2."

#: transforms-tensor.R:184
msgid "Padding must be an int or a 1, 2, or 4 element numeric vector"
msgstr ""
"`padding` doit être un entier, ou un vecteur numérique de taille 1, 2 ou 4."

#: transforms-tensor.R:187
msgid "Padding mode should be either constant, edge, reflect or symmetric"
msgstr ""
"Le bourrage `padding_mode` doit être pris parmi `constant`, `edge`, "
"`reflect` ou `symmetric`."

#: transforms-tensor.R:208
msgid "Padding can not be negative for symmetric padding_mode"
msgstr ""
"le bourrage `padding` ne peut pas être négatif avec le mode `symmetric`."

#: transforms-tensor.R:246 transforms-tensor.R:272
msgid "Please provide only 2 dimensions (h, w) for size."
msgstr ""
"Le vecteur de `size` doit contenir seulement les deux dimensions (h, w)."

#: transforms-tensor.R:255
msgid "Requested crop size is bigger than input size."
msgstr ""
"Le détourage demandée avec `crop` est de taille plus grande que l'entrée."

#: transforms-tensor.R:338
msgid "brightness factor is negative"
msgstr "`brightness_factor` doit être positif."

#: transforms-tensor.R:349
msgid "contrast must be positive"
msgstr "`contrast` doit être positif."

#: transforms-tensor.R:362
msgid "hue_factor must be between -0.5 and 0.5."
msgstr "`hue_factor` doit être pris entre -0.5 et 0.5"

#: transforms-tensor.R:387
msgid "saturation factor must be positive."
msgstr "`saturation_factor` doit être positif."

#: transforms-tensor.R:419
msgid "`angle` should be int or float"
msgstr "`angle` doit être un entier ou un réel."

#: transforms-tensor.R:422
msgid "`translate` should be length 2"
msgstr "`translate` devrait être de longueur 2."

#: transforms-tensor.R:425
msgid "`scale` should be positive"
msgstr "`scale` doit être positif."

#: transforms-tensor.R:428
msgid "`shear` should be either a single value or a sequence of 2 values"
msgstr ""
"`shear` doit être une valeur simple ou un vecteur de deux valeurs numériques."

#: transforms-tensor.R:442
msgid "`transform_perspective` is not implemented yet."
msgstr "`transform_perspective` n'est pas encore implémenté."

#: transforms-tensor.R:459
msgid "tensor is not a torch image."
msgstr "Le tenseur n'est pas une image torch."

#: transforms-tensor.R:743
msgid "Symmetric padding of N-D tensors are not supported yet"
msgstr ""
"Le bourrage en mode `symmetric` de tenseurs de dimension N n'est pas encore "
"implémenté."

#: transforms-tensor.R:752
msgid "gamma must be non-negative"
msgstr "`gamma` doit être positif."

#: utils.R:43
msgid "Pretrained weights on COCO require {.var num_classes} to be {.val 21}."
msgstr ""
"Les poids pré-entraînés sur COCO nécessitent {.var num_classes} à {.val 21}."

#: utils.R:46
msgid ""
"Pretrained weights on ADE20K require {.var num_classes} to be {.val 150}."
msgstr ""
"Les poids pré-entraînés sur ADE20K nécessitent {.var num_classes} à {.val "
"150}."

#: vision_utils.R:109
msgid "The provided x class {.class {class(x)}} is not supported"
msgstr "la classe fournie {.cls {class(x)}} n'est pas supportée."

#: vision_utils.R:122 vision_utils.R:231 vision_utils.R:322 vision_utils.R:437
msgid "magick"
msgstr ""

#: vision_utils.R:129
msgid "Pass an individual image as `x`, not a batch"
msgstr "Il faut passer une image individuelle en `x`, et non un batch."

#: vision_utils.R:132 vision_utils.R:329 vision_utils.R:445 vision_utils.R:507
#: vision_utils.R:537
msgid "Only grayscale and RGB images are supported"
msgstr "Seules les images en niveau de gris et RGB son prise en compte."

#: vision_utils.R:139
msgid "`x` should be of dtype `torch_uint8` or `torch_float`"
msgstr "`x` doit être de type `torch_uint8` ou `torch_float`"

#: vision_utils.R:142
msgid ""
"Boxes need to be in c(xmin, ymin, xmax, ymax) format. Use `box_convert()` to "
"convert them"
msgstr ""
"Les boîtes doivent être au format c(xmin, ymin, xmax, ymax). Utilisez "
"`box_convert()` pour les convertir"

#: vision_utils.R:146
msgid "boxes doesn't contain any box. No box was drawn"
msgstr "`boxes` ne contient aucun cadre. Aucun cadre n'a été tracé."

#: vision_utils.R:151
msgid ""
"Number of labels {.val {length(labels)}} cannot be broadcasted on number of "
"boxes {.val {num_boxes}}"
msgstr ""
"Le nombre d'étiquettes {.val {length(labels)}} n'est pas un multiple et ne "
"peut donc pas être broadcasté sur le nombre de boites {.val {num_boxes}}."

#: vision_utils.R:158
msgid "colors vector cannot be broadcasted on boxes"
msgstr ""
"le vecteur de couleurs ne peut pas être broadcasté sur les boites (nombres "
"non multiples l'un de l'autre)"

#: vision_utils.R:265
msgid "Mask matrix dimensions (%d x %d) don't match expected (%d x %d)"
msgstr ""
"Les dimensions de la matrice de masque (%d x %d) ne correspondent pas aux "
"dimensions attendues (%d x %d)"

#: vision_utils.R:313
msgid ""
"The provided object of class {.cls {class(x)}} is not supported by "
"draw_segmentation_masks."
msgstr ""
"L'objet fourni de classe {.cls {class(x)}} n'est pas pris en charge par "
"`draw_segmentation_masks()`."

#: vision_utils.R:326 vision_utils.R:442 vision_utils.R:504 vision_utils.R:534
msgid "Pass individual `image`, not batches"
msgstr "Il faut passer une image individuelle en `x`, et non un batch."

#: vision_utils.R:336
msgid "`x` (image) should be of dtype `torch_uint8` or `torch_float`"
msgstr "`x` (image) doit être de type `torch_uint8` ou `torch_float`"

#: vision_utils.R:343
msgid "`masks` must be of shape (H, W) or (num_masks, H, W)"
msgstr "`masks` doit être de forme (H, W) ou (num_masks, H, W)"

#: vision_utils.R:347
msgid "`masks` is expected to be of dtype torch_bool() or torch_float()"
msgstr "`masks` doit être de type `torch_bool()` ou `torch_float()`."

#: vision_utils.R:350
msgid "`masks` and `image` must have the same height and width"
msgstr "`masks` et `image` doivent avoir la même hauteur et la même largeur"

#: vision_utils.R:363
msgid "masks doesn't contain any mask. No mask was drawn"
msgstr "`masks` ne contient pas de masque. Aucun masque ne sera tracé."

#: vision_utils.R:371
msgid ""
"colors vector of size {.value {length(colors)}} cannot be broadcasted on "
"{.value {num_masks}} masks"
msgstr ""
"le vecteur de couleurs de taille {.value {length(colors)}} ne peut pas être "
"broadcasté sur les {.value {num_masks}} masques"

#: vision_utils.R:439
msgid "`image` should be a torch_tensor"
msgstr "Le tenseur n'est pas une image torch."

#: vision_utils.R:452
msgid "`image` should be of dtype `torch_uint8` or `torch_float`"
msgstr "`image` doit être de type `torch_uint8` ou `torch_float`"

#: vision_utils.R:456
msgid ""
"{.var keypoints} must be of shape (num_instances, K, 2), but is current "
"shape is {.value {keypoints$shape}}"
msgstr ""
"{.var keypoints} doit être de taille (num_instances, K, 2), pourtant sa "
"taille actuelle est {.value {keypoints$shape}}"

#~ msgid "Pass individual `x`, not batches"
#~ msgstr "Il faut passer des `x` individuels, et non en batch."

#~ msgid "{.cls {class(self)[[1]]}} dataset processed successfully!"
#~ msgstr ""
#~ "Le jeu de données {.cls {class(self)[[1]]}} a été préparé avec succès."

#~ msgid "Image file not found:"
#~ msgstr "Fichier d'image introuvable."

#~ msgid "{.var cell_anchors} should not be NULL"
#~ msgstr "{.var cell_anchors} ne peuvent pas être NULL."

#~ msgid "Anchors should be a list(list(int)) because each feature"
#~ msgstr "`anchors` doivent être une `list(list(integer))` car chaque feature"

#~ msgid "map could potentially have different sizes and aspect ratios."
#~ msgstr ""
#~ "caractéristique peut potentiellement avoir des tailles et des rapports "
#~ "d'aspet différents."

#~ msgid "There needs to be a match between the number of"
#~ msgstr "Le nombre de feature map et le nombre de tailles / rapport de forme"

#~ msgid ""
#~ "feature maps passed and the number of sizes / aspect ratios specified."
#~ msgstr "doivent être identiques"

#~ msgid "{.var aspect_ratios} and {.var steps} should have the same length"
#~ msgstr "{.var aspect_ratios} et {.var steps} doivent être de même taille."

#~ msgid "Corrupt file! Delete the file in {.file {archive}} and try again."
#~ msgstr ""
#~ "Fichier corrompu. Supprimez le fichier dans {.file {archive}} et "
#~ "réessayez."
